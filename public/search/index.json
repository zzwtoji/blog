[{"content":" 原文法：S $\\rightarrow$bBB 移进： S $\\rightarrow \\cdot$ bBB 归约： S $\\rightarrow$ bBB$\\cdot$ 待约： S $\\rightarrow$ b$\\cdot$BB LR(0) 文法 拓广文法。 LR(0) 有限自动机 DFA。 LR(0) 分析表。 分析流程。 e.g.\nS $\\rightarrow$ CC\nC $\\rightarrow$ cC | d\n拓广文法：\n（0）S\u0026rsquo; $\\rightarrow$ S\n（1）S $\\rightarrow$ CC\n（2）C $\\rightarrow$ cC\n（3）C $\\rightarrow$ d\n项目集族：\n$I_0$ S\u0026rsquo; $\\rightarrow$ $\\cdot$ S S $\\rightarrow$ $\\cdot$ CC C $\\rightarrow$ $\\cdot$ cC C $\\rightarrow$ $\\cdot$ d $I_0 \\stackrel{S}{\\longrightarrow} I_1$ S\u0026rsquo; $\\rightarrow$ S $\\cdot$ $I_0 \\stackrel{C}{\\longrightarrow} I_2$ S $\\rightarrow$ C $\\cdot$ C C $\\rightarrow$ $\\cdot$ cC C $\\rightarrow$ $\\cdot$ d $I_0 \\stackrel{c}{\\longrightarrow} I_3$ C $\\rightarrow$ c $\\cdot$ C C $\\rightarrow$ $\\cdot$ cC C $\\rightarrow$ $\\cdot$ d $I_0 \\stackrel{d}{\\longrightarrow} I_4$ C $\\rightarrow$ d $\\cdot$ $I_2 \\stackrel{C}{\\longrightarrow} I_5$ S $\\rightarrow$ CC $\\cdot$ $I_2 \\stackrel{c}{\\longrightarrow} I_3$ $I_2 \\stackrel{d}{\\longrightarrow} I_4$ $I_3 \\stackrel{C}{\\longrightarrow} I_6$ C $\\rightarrow$ cC $\\cdot$ $I_3 \\stackrel{c}{\\longrightarrow} I_3$ $I_3 \\stackrel{d}{\\longrightarrow} I_4$ （图片缺了这根） LR(0) 分析表：\nACTION ACTION ACTION GOTO GOTO c d $ S C 0 S3 S4 1 2 1 acc 2 S3 S4 5 3 S3 S4 6 4 R3 R3 R3 5 R1 R1 R1 6 R2 R2 R2 FOLLOW 集：\nS $\\rightarrow$ CC\nC $\\rightarrow$ cC | d\nFOLLOW(S) = { $ }\nFOLLOW(C) = { c, d, $ }\nSLR(1) 分析表：\nACTION ACTION ACTION GOTO GOTO c d $ S C 0 S3 S4 1 2 1 acc 2 S3 S4 5 3 S3 S4 6 4 R3 R3 R3 5 R1 6 R2 R2 R2 ","date":"2025-12-10T17:06:34+08:00","image":"https://megumi8821.netlify.app/img/PrincipleofCompile.svg","permalink":"https://megumi8821.netlify.app/p/lr0-slr1/","title":"LR(0) SLR(1)"},{"content":"左递归 产生式左侧字母和右侧首字母相同，$S \\rightarrow Sa$。\n消除左递归 $$ P \\rightarrow P \\alpha | \\beta \\Rightarrow\\left\\{ \\begin{array}{rcl} P \\rightarrow \\beta P'\\\\ P' \\rightarrow \\alpha P' | \\epsilon \\end{array} \\right. $$左公因子 产生式右侧有多个产生式以相同符号开头，$P \\rightarrow \\alpha \\beta_1 | \\alpha \\beta_2$，$P \\rightarrow \\alpha（ \\beta_1 | \\beta_2）$。\n消除左公因子 $$ P \\rightarrow \\alpha \\beta_1 | \\alpha \\beta_2 \\Rightarrow\\left\\{ \\begin{array}{rcl} P \\rightarrow \\alpha P'\\\\ P' \\rightarrow \\beta_1 | \\beta_2 \\end{array} \\right. $$FIRST 集 A $\\rightarrow$ aB，FIRST(A)={a} A $\\rightarrow$ aB| $\\epsilon$，FIRST(A)={a，$\\epsilon$} A $\\rightarrow$ BCD，FIRST(A)=FIRST(B)，B $\\nrightarrow$ $\\epsilon$ A $\\rightarrow$ BCD 且 B $\\rightarrow$ $\\epsilon$，FIRST(A)={FIRST(C)} A $\\rightarrow$ a，FIRST(A)={a} FOLLOW 集 $ 为开始符号，FOLLOW(S)={$，\u0026hellip;} A $\\rightarrow$ $\\alpha B \\beta$，FOLLOW(B)=FIRST($\\beta$) - {$\\epsilon$} A $\\rightarrow$ $\\alpha B \\beta$ 且 $\\beta \\rightarrow \\epsilon$，FOLLOW(B)=FOLLOW(A) SELECT 集 $A \\rightarrow \\alpha$ 若 $\\alpha \\rightarrow \\epsilon$，则 SELECT(A $\\rightarrow \\alpha$)=FOLLOW(A) 若 $\\alpha \\nrightarrow \\epsilon$，则 SELECT(A $\\rightarrow \\alpha$)=FIRST($\\alpha$) 判断 LL(1) 文法 不含左递归。 不含左公因子。$A \\rightarrow aB| \\epsilon$，则 $A \\rightarrow aB$ 和 $A \\rightarrow \\epsilon$ 的 FIRST 集无交集。 FIRST 集中含有 $\\epsilon$ 时，FIRST(A) $\\cap$ FOLLOW(A)=$ \\emptyset $。 e.g.\nE $\\rightarrow$ E + T | T\nT $\\rightarrow$ T * F | F\nF $\\rightarrow$ ( E ) | i\n消除左递归：\nE $\\rightarrow$ T E\u0026rsquo;\nE\u0026rsquo; $\\rightarrow$ + T E\u0026rsquo; | $\\epsilon$\nT $\\rightarrow$ F T\u0026rsquo;\nT\u0026rsquo; $\\rightarrow$ * F T\u0026rsquo; | $\\epsilon$\nF $\\rightarrow$ ( E ) | i\n计算 FIRST 集：\nFIRST(E)={FIRST(T)}={ ( , i }\nFIRST(E\u0026rsquo;)={ + , $\\epsilon$ }\nFIRST(T)={FIRST(F)}={ ( , i }\nFIRST(T\u0026rsquo;)={ * , $\\epsilon$ }\nFIRST(F)={ ( , i }\n计算 FOLLOW 集：\nFOLLOW(E)={$ , ) }\nFOLLOW(E\u0026rsquo;)={FOLLOW(E)}={$ , ) }\nFOLLOW(T)={FIRST(E\u0026rsquo;)} - {$\\epsilon$} $\\cup$ FOLLOW(E)={ + , $ , ) }\nFOLLOW(T\u0026rsquo;)={FOLLOW(T)}={ + , $ , ) }\nFOLLOW(F)={FIRST(T\u0026rsquo;)} - {$\\epsilon$} $\\cup$ FOLLOW(T)={ * , + , $ , ) }\n计算 SELECT 集：\nSELECT(E $\\rightarrow$ T E\u0026rsquo;)=FIRST(T)={ ( , i }\nSELECT(E\u0026rsquo; $\\rightarrow$ + T E\u0026rsquo;)={ + }\nSELECT(E\u0026rsquo; $\\rightarrow$ $\\epsilon$)=FOLLOW(E\u0026rsquo;)={$ , ) }\nSELECT(T $\\rightarrow$ F T\u0026rsquo;)=FIRST(F)={ ( , i }\nSELECT(T\u0026rsquo; $\\rightarrow$ * F T\u0026rsquo;)={ * }\nSELECT(T\u0026rsquo; $\\rightarrow$ $\\epsilon$)=FOLLOW(T\u0026rsquo;)={ + , $ , ) }\nSELECT(F $\\rightarrow$ ( E ))={ ( }\nSELECT(F $\\rightarrow$ i)={ i }\n分析表：\n( ) i + * $ E E→TE' E→TE' E' E\u0026rsquo;→ε E\u0026rsquo;→+TE' E\u0026rsquo;→ε T T→FT' T→FT' T' T\u0026rsquo;→ε T\u0026rsquo;→ε T\u0026rsquo;→*FT' T\u0026rsquo;→ε F F→(E) F→i 对输入串 i*i+i 的分析过程：\n栈 输入串 输出 $E i*i+i$ $E\u0026rsquo;T i*i+i$ E→TE' $E\u0026rsquo;T\u0026rsquo;F i*i+i$ T→FT' $E\u0026rsquo;T\u0026rsquo;i i*i+i$ F→i $E\u0026rsquo;T' *i+i$ $E\u0026rsquo;T\u0026rsquo;F* *i+i$ T\u0026rsquo;→*FT' $E\u0026rsquo;T\u0026rsquo;F i+i$ $E\u0026rsquo;T\u0026rsquo;i i+i$ F→i $E\u0026rsquo;T' +i$ $E' +i$ T\u0026rsquo;→$\\epsilon$ $E\u0026rsquo;T+ +i$ E\u0026rsquo;→+TE' $E\u0026rsquo;T i$ $E\u0026rsquo;T\u0026rsquo;F i$ T→FT' $E\u0026rsquo;T\u0026rsquo;i i$ F→i $E\u0026rsquo;T' $ $E' $ T\u0026rsquo;→$\\epsilon$ $ $ E\u0026rsquo;→$\\epsilon$ ","date":"2025-12-10T15:01:14+08:00","image":"https://megumi8821.netlify.app/img/PrincipleofCompile.svg","permalink":"https://megumi8821.netlify.app/p/ll1-%E6%96%87%E6%B3%95/","title":"LL(1) 文法"},{"content":"正规文法 $A \\rightarrow aB$ 或 $A \\rightarrow a$\n推出“1 个终结符+非终结符”或“1 个终结符”。\n正规式 $\\rightarrow$ 正规文法 $A \\rightarrow x|y \\Rightarrow A \\rightarrow x, A \\rightarrow y$ $A \\rightarrow xy \\Rightarrow A \\rightarrow xB, B \\rightarrow y$ $A \\rightarrow x^*y \\Rightarrow A \\rightarrow xA, A \\rightarrow y$ 正规文法 $\\rightarrow$ 正规式 $A \\rightarrow xB, B \\rightarrow y \\Rightarrow A = xy$ $A \\rightarrow xA|y \\Rightarrow A = x^*y$ $A \\rightarrow x, A \\rightarrow y \\Rightarrow A = x|y$ NFA 状态图 $e.g. (\\epsilon|a)b^*$\nNFA 转 DFA 求初态闭包：以 NFA 初态为起点，经 $\\epsilon$ 边可达的所有状态构成 DFA 初态； 对每个 DFA 状态，遍历所有输入符号： 先求该状态的“符号转移集”（沿符号边可达的 NFA 状态）； 再求转移集的 $\\epsilon$ 闭包，得到新的 DFA 状态； 重复步骤 2，直到无新 DFA 状态生成； 标记含 NFA 终态的 DFA 状态为终态。 $e.g. a(a|b)^*$\nNFA: a b {0, 1, 2, 3, 7} {1, 2, 3, 4, 6, 7} {1, 2, 3, 5, 6, 7} {1, 2, 3, 4, 6, 7} {1, 2, 3, 4, 6, 7} {1, 2, 3, 5, 6, 7} {1, 2, 3, 5, 6, 7} {1, 2, 3, 4, 6, 7} {1, 2, 3, 5, 6, 7} DFA:\n最小化 DFA 划分初始状态集： 终态集（双圈） 非终态集 对每个状态集，检查每个输入符号的转移目标是否在同一状态集内，若存在状态转移目标分属不同子集，则按转移目标的差异划分子集。 重复步骤 2，直到无法再划分； 每个状态集合并为 DFA 的一个状态，转移关系继承自原 DFA。含原 DFA 终态的合并状态，标记为最小 DFA 的终态。 $e.g. a(a|b)^*$\nDFA:\n终态集：{A, B, C}，非终态集：$\\emptyset$\n划分后，终态集：{A}，非终态集：$\\emptyset$\n最小化 DFA:\n","date":"2025-12-10T11:40:52+08:00","image":"https://megumi8821.netlify.app/img/PrincipleofCompile.svg","permalink":"https://megumi8821.netlify.app/p/%E6%AD%A3%E8%A7%84%E5%BC%8F-%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95/","title":"正规式 正规文法"},{"content":"概念 文法 句型：由“ $\\rightarrow$ ” 推导出的符号串。 句子：句型中只含有终结符。 终结符：小写字母、+、-、*、/、=和标点符号。 非终结符：大写字母和尖括号\u0026lt;\u0026gt;包裹的符号。 语言 L（G）：一切句子的集合。 短语 短语：所有非终结符的所有子树的叶子节点按顺序连接的符号串。 直接短语：一步推导的短语。 句柄：最左边的直接短语。 素短语：至少含有 1 个终结符且除自身外不再含有更小的素短语。 最左素短语：最左边的素短语。 最左推导 每次优先选择句型中最左侧的非终结符进行替换，逐步推导出句子的过程。\n最右推导（规范推导） 每次优先选择句型中最右侧的非终结符进行替换，推导顺序与语法分析中的归约过程相反。\n语法推导树 以文法的开始符号为根节点、非终结符为中间节点、终结符为叶节点，直观反映句子从开始符号经规则替换逐步生成过程的树形结构。\n二义性文法：存在至少一个句子，对应两种及以上不同语法推导树。 无二义性文法：所有句子都只有唯一的语法推导树。 二义性是文法属性。一个存在二义性的文法，可以通过修改规则变成无二义性的文法。 ","date":"2025-12-09T19:40:40+08:00","image":"https://megumi8821.netlify.app/img/PrincipleofCompile.svg","permalink":"https://megumi8821.netlify.app/p/%E6%96%87%E6%B3%95-%E8%AF%AD%E6%B3%95%E6%A0%91-%E7%9F%AD%E8%AF%AD/","title":"文法 语法树 短语"},{"content":"定义 盒图又称 N-S 图，是一种无箭头的流程图。它用矩形框表示程序的各种逻辑结构），所有流程控制都通过盒子的嵌套或并列实现\n核心结构 顺序结构 按从上到小的顺序依次执行多个操作。 选择结构（分支结构） 循环结构 多情况选择结构（for 循环专用） 子程序调用结构 优势 应用场景 ","date":"2025-11-24T14:40:18+08:00","image":"https://megumi8821.netlify.app/img/SoftwareEngineering.svg","permalink":"https://megumi8821.netlify.app/p/%E7%9B%92%E5%9B%BE/","title":"盒图"},{"content":"问题定义与可行性分析 明确为什么要做这项目，判断项目是否值得推进。\n问题识别：与客户、业务沟通，明确痛点，界定边界。 需求初步收集：收集用户模糊需求，聚焦核心诉求。 可行性分析 技术可行性：评估现有技术、硬件资源和团队开发能力是否支持需求实现。 经济可行性：估算项目成本与预期收益，判断投资回报率。 操作可行性：评估软件交付后，用户能否快速上手，现有业务流程是否需要调整。 法律可行性：确保项目符合相关法律法规要求，避免法律风险。 决策输出：编写可行性分析报告，供决策参考是否启动项目。 需求分析 将模糊需求转化为可量化、可验证、无歧义的需求规格。\n需求细化与结构化 功能需求：拆解核心流程，明确各流程的输入、输出和异常处理。 非功能需求：量化关键指标。 约束条件：技术、业务、法律等方面的限制。 需求建模与验证 用例图（UML，Unified Modeling Language）：展示系统与外部实体的交互。 用户故事：描述用户视角下的需求场景。 需求评审：组织多方评审会议，确保需求准确完整。 输出文档：《需求规格说明书》（SRS，Software Requirements Specification），包含功能清单、非功能指标、用例图、用户故事和验收标准。 软件设计 明确怎么做，降低开发复杂度，保证系统可扩展、可维护。\n概要设计（架构设计） 架构选型：选择合适架构模式，明确技术栈。 模块划分：确定系统的主要模块及其职责。 接口设计：定义模块间的交互接口。 数据架构设计：设计数据库结构和数据流。 输出文档：《概要设计说明书》。 详细设计 模块内部逻辑设计：使用流程图、伪代码描述模块核心逻辑。 数据结构设计：定义变量类型、集合类型和自定义数据结构。 算法设计：针对复杂功能选择合适算法，明确算法的输入、输出和时间复杂度。 数据库物理设计：将逻辑模型转化为物理表结构，定义字段类型和约束。 界面原型设计：设计用户界面原型，明确交互逻辑。 输出文档：《详细设计说明书》。 编码实现 按详细设计编写可运行、高质量的代码，完成单元测试。\n开发环境搭建 代码编写规范 模块开发与集成 单元测试 代码评审 输出成果：可执行代码、单元测试报告、代码评审报告和编译后的可执行文件。 软件测试 验证软件是否满足需求规格，发现并修复缺陷。\n单元测试 执行主体：开发人员\n核心任务：测试单个模块、方法的功能正确性，不依赖其他模块。\n集成测试 执行主体：测试人员\n核心任务：测试模块间接口调用是否正常，模块协作是否符合设计要求。\n测试方法：按集成策略逐步集成模块，编写集成测试用例，重点测试接口参数传递、数据格式转换和异常处理。\n系统测试 执行主体：测试人员\n核心任务：在完整系统环境下测试软件整体功能和性能，验证是否满足需求规格。\n测试类型：\n功能测试 性能测试 安全性测试 兼容性测试 易用性测试 验收测试 执行主体：用户\n核心任务：按《需求规格说明书》的验收标准，验证软件是否符合业务需求。\n缺陷管理 记录缺陷信息，使用缺陷跟踪工具跟踪缺陷修复进度，确保所有缺陷得到及时处理。\n对未修复的严重缺陷进行风险评估，决定是否延期发布或增加补丁计划。\n输出文档 《测试计划》《测试用例》《测试报告》和《缺陷报告》。\n部署与维护 将软件交付给用户，确保其正常运行，并根据用户反馈进行维护和升级。\n部署阶段 环境准备：配置生产环境，确保硬件资源满足系统运行需求。 部署实施：使用部署工具将软件包部署到生产服务器，配置数据库连接、端口和日志路径等参数。 数据迁移：将旧系统数据迁移到新系统，确保数据完整性和一致性。 上线验证：部署后进行冒烟测试，监控系统运行状态，确保无重大问题。 用户培训：对用户进行系统操作培训，确保用户能够熟练使用软件。 维护阶段 纠错维护（紧急维护）：响应用户反馈的 bug，快速定位问题，修复并部署到生产环境。 适应性维护：当外部环境变化时，修改软件以适配新环境。 完善性维护：根据用户需求和技术发展，增加新功能或改进现有功能。 预防性维护：定期对系统进行优化，修复潜在隐患。 维护记录：详细记录维护过程和变更内容，便于追踪和管理。 输出成果：《部署文档》《用户手册》《维护报告》和优化后的软件版本。\n","date":"2025-11-24T13:29:41+08:00","image":"https://megumi8821.netlify.app/img/SoftwareEngineering.svg","permalink":"https://megumi8821.netlify.app/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"软件工程生命周期"},{"content":"协议所属网络层 协议 网络层级 HTTP 应用层 TCP 运输层 UDP 运输层 连接特性 连接方式 HTTP：间接连接，HTTP 在请求/响应前需先通过 TCP 建立连接，再传输数据。 TCP：面向连接，传输前需通过三次握手建立连接，四次挥手断开连接。 UDP：无连接，直接发送数据，无需断开流程。 连接持续性 HTTP HTTP/1.0：短连接，每次请求后断开 TCP 连接。 HTTP/1.1：长连接，同一域名下多个请求复用一个 TCP 连接。 HTTP/2：多路复用，多个请求在一个 TCP 连接上并发传输。 TCP：建立连接后保持连接状态，可持续传输多批数据，直到双方发起断开请求。 UDP：每次发送数据都是独立的数据包，无连接保持逻辑。 可靠性 HTTP 依赖 TCP 实现可靠性。\nHTTP 本身不具备重传、校验机制，数据是否丢失、有序，完全由底层 TCP 负责。\nTCP 可靠传输。\n确认机制：接收方发 ACK 确认数据送达。 重传机制：超时未收到 ACK 则重传数据。 有序传输：通过序号标记数据顺序，接收方按序重组。 流量控制：防止发送方过快发送数据，避免接收方缓存溢出。 拥塞控制：根据网络状况调整发送速率，防止网络拥塞。 UDP 不可靠传输。\n无确认机制：发送数据后不等待接收方确认，无法确认数据是否送达。 无重传机制：数据丢失后不进行重传。 无序传输：数据包可能乱序到达，接收方需自行处理顺序问题。 无流量控制和拥塞控制：发送方按自身速率发送数据，可能导致接收方丢包。 数据完整性 HTTP 依赖 TCP 的校验。\nHTTP 数据完整性由 TCP 帧尾的 FCS 校验来保障，其自身仅通过部分头信息字段来辅助检测数据完整性。\nTCP 多层校验。\nTCP 校验：检测端到端的传输错误，检验整个 TCP 段。 FCS 校验：检测链路层传输错误，检验整个帧。 UDP 基础校验。\nUDP 头部含校验和字段，仅对数据报进行简单校验，校验失败则直接丢弃，不反馈、不重传。\n传输效率 HTTP HTTP/1.0：每次请求建立新连接，开销大，效率低。 HTTP/1.1：长连接复用，减少连接开销，提高效率。 HTTP/2：多路复用，多个请求并发传输，进一步提升效率。 TCP 效率低：连接建立和维护开销大，拥塞控制和流量控制机制降低传输速率。\nUDP 效率高：无连接开销，无拥塞和流量控制，数据报头部仅 8 字节。\n适用场景 HTTP 网页加载 API 通信 TCP 可靠数据传输 远程登录 文件传输 UDP 实时通信 视频直播 在线游戏 DNS 查询 数据格式与传输单元 HTTP 数据格式 请求报文 请求行：请求方法+请求路径+协议版本 请求头：键值对形式的元数据，用于告知服务器请求的附加信息。 请求体：可选部分，常用于 POST 请求，用来传递表单数据、JSON 等内容。 响应报文 状态行：协议版本+状态码+状态描述 响应头：键值对形式的元数据，用于告知客户端响应的附加信息。 响应体：服务器返回的实际数据内容，如 HTML 页面、JSON 数据等。 传输单元 HTTP 本身没有专属传输单元。发送方将 HTTP 的整份报文拆成若干部分，融进 TCP 的字节流。接收方再通过 TCP 重组字节流，还原成完整的 HTTP 报文。\nTCP 数据格式 TCP 不关心应用层数据的具体格式，不论是 HTTP 报文还是文件数据，都会统一封装成 TCP 段。\n每个 TCP 段的头部至少 20 字节，包含源端口、目标端口、序列号和确认号等关键信息。\n传输单元 TCP 的传输单元是 TCP 段。段的大小受 MTU 限制。TCP 总长度超出 MTU 后就会被拆分成多个段传输。\nUDP 数据格式 UDP 不关心应用层数据的具体格式，任何数据都可以封装成 UDP 数据报。\n每个 UDP 数据报的头部固定 8 字节，只包含源端口、目标端口、数据包长度、校验和 4 个字段。\n传输单元 UDP 的传输单元是 UDP 数据报。每个数据报独立传输，大小受 MTU 限制，超出部分会被丢弃。\n端口号与通信对象 协议 端口号范围 通信对象 HTTP 80（未加密）\n443（加密） 应用层的客户端和服务器，通过域名+端口定位服务器应用 TCP 无默认端口，由应用层协议指定\nSSH：22 基于“源 IP+源端口+目标 IP+目标端口”定位端到端连接，实现两台设备间的双向通信 UDP 无默认端口，由应用层协议指定\nDNS：53\nDHCP：67/68 基于“源 IP+源端口+目标 IP+目标端口”定位通信对象，仅单向发送数据报 应用场景 HTTP 网页浏览 接口调用 文件下载 TCP 文件传输 邮件收发 远程登录 HTTP/1.0/1.1/2 的传输载体 UDP 实时通信 视频直播 在线游戏 DNS 查询 HTTP/3 的传输载体 协议间的依赖关系 HTTP 与 TCP 的依赖：HTTP 所有数据必须通过 TCP 连接传输，TCP 为 HTTP 提供可靠的数据通道。 HTTP 与 UDP 的关系：HTTP 本身不使用 UDP 进行传输，但 HTTP/3 采用 QUIC 协议，QUIC 基于 UDP 实现，提供类似 TCP 的可靠传输功能。 ","date":"2025-11-24T09:05:14+08:00","image":"https://megumi8821.netlify.app/img/ComputerNetworks.svg","permalink":"https://megumi8821.netlify.app/p/http-%E4%B8%8E-tcpudp-%E7%9A%84%E5%B7%AE%E5%BC%82/","title":"HTTP 与 TCP、UDP 的差异"},{"content":"五层模型从上到下依次为应用层、运输层、网络层、链路层、物理层。每一层只负责特定的功能，再通过与上下层的协作，完成端到端的数据传输。\n应用层 直接面向用户，提供各类网络应用服务。\n功能 定义应用程序间的通信规则。 处理数据格式。 管理会话，协调通信双方的交互逻辑。 管理什么会话 端到端交互链路 交互状态 如何管理 建立会话 维护会话 终止会话 关键协议 HTTP/HTTPS：网页传输协议 SMTP：邮件传输协议 FTP：文件传输协议 DNS：域名解析协议 运输层 负责将应用层的数据打包后，通过端口号定位到目标设备的具体应用，实现端到端的可靠传输。\n功能 建立端到端的联系 选择传输方式 可靠传输 不可靠传输 处理流量控制和拥塞控制 通过端口号识别目标应用 关键协议 TCP：传输控制协议 可靠、面向连接：传输前必须先进行三次握手，传输过程中确认数据是否送达、重传丢失的数据，并通过窗口机制控制流量和拥塞。\n适用于对数据可靠性有较高要求的场景：\n网页加载 文件下载 邮件发送 三次握手 客户端发送 SYN 包请求连接 服务器响应 SYN-ACK 包，表示同意连接 客户端发送 ACK 包，确认连接建立 四次挥手 客户端发送 FIN=1（请求断开），ACK=1（确认之前的数据），序号=X。 服务器回复 ACK=1（确认收到断开请求），序号=Y，确认号=X+1。 服务器发送 FIN=1（请求断开），ACK=1（确认之前的数据），序号=Z，确认号=X+1。 客户端回复 ACK=1（确认收到断开请求），序号=X+1，确认号=Z+1。 序号 标记发送方当前发送数据的字节位置，确保接收方按序重组数据。 TCP 连接建立时，双方会随机生成初始序号（ISN），避免因旧连接的残留报文干扰。 序号值=初始序号+已发送字节数 确认号 确认号值=期望接收的下一个字节序号=已接收字节的最后序号+1 确认号仅在 ACK 标志位为 1 时有效。 窗口 实现流量控制和拥塞控制，防止发送方发送过多数据淹没接收方。 窗口值存储在 TCP 头部的窗口字段中，单位为字节，基于接收方缓冲区动态调整。 发送方需确保：未确认的数据总量 ≤ 接收方告知的窗口值 标志位 SYN（Synchronize）：同步序号，用于建立连接。 ACK（Acknowledgment）：确认标志，表示报文包含确认号。 FIN（Finish）：结束标志，用于终止连接。 RST（Reset）：复位标志，用于处理异常情况，强制断开连接。 PSH（Push）：推送标志，要求接收方立即将数据交给应用层。 URG（Urgent）：紧急标志，表示报文中有紧急数据，需要优先处理。 UDP：用户数据报协议 无连接、不可靠、低延迟：传输前不需要建立连接，发送后不确认数据是否送达，无流量控制和拥塞控制，但传输速度快、开销小。\n适用于对延迟敏感、能容忍少量丢包的场景：\n视频通话 DNS 查询 直播 网络层 将传输层的数据包从源设备发送到目标设备。\n功能 定义设备的 IP 地址。 当数据包超过网络的最大传输单元 MTU（Maximum Transmission Unit，一次能传输的最大数据块大小）时，拆分成小片段传输，到达目标后再重组。 通过路由协议选择最优传输路径。 处理网络差错。 数据丢失。 数据损坏。 数据重复。 数据失序。 延迟超限。 关键协议 IP：网际协议 负责给每个设备分配唯一的 IP 地址，并指导数据包在网络中传输。\nIPv4：32 位地址。 IPv6：128 位地址。 TTL（Time To Live，生存时间）：防止数据包在网络中无限循环，通过每经过一个路由器，TTL 值减 1，直到为 0 时丢弃数据包。 ICMP：互联网控制报文协议 辅助 IP 协议，用于发送网络差错报文和测试网络连通性。\nping 命令就是基于 ICMP 的请求/响应报文实现的。 路由协议 用于路由器之间交换路由信息，选择最佳路径传输数据包。\nOSPF：内部网关协议，用于同一公司/机构内部的路由选择。 BGP：外部网关协议，用于不同运营商之间的路由选择。 链路层 在同一个局域网内，将网络层的 IP 数据包封装成帧，通过 MAC（Media Access Control，媒体访问控制）地址定位到目标设备，实现点对点的传输。\n功能 定义物理地址（MAC 地址），每个网卡的 MAC 地址全球唯一。 将 IP 数据包封装成以太网帧，添加帧头和帧尾信息，帧头包含源 MAC 地址和目标 MAC 地址，帧尾包含校验信息。 处理帧的检验，通过帧尾的 FCS（Frame Check Sequence，帧校验序列）字段检查帧在传输过程中是否损坏，损坏则丢弃。 管理局域网内的设备接入。 关键协议与设备 MAC 地址：6 字节的物理地址，用于局域网内识别设备。 以太网帧：局域网内传输的数据单元，包含帧头、数据和帧尾。 ARP（Address Resolution Protocol，地址解析协议）：将 IP 地址映射到 MAC 地址。 交换机：根据 MAC 地址转发以太网帧，只将帧发送到目标 MAC 对应的端口。 链路层协议 PPP（Point-to-Point Protocol，点对点协议）：用于点对点连接的数据链路层协议，常用于拨号上网。 802.11（无线局域网协议）：定义无线局域网的链路层标准。 物理层 将帧转换成比特流，通过物理介质传输。\n功能 定义物理介质的电气、光学和无线特性。 处理比特流的传输。 管理物理连接的时序。 定义带宽。 关键概念 比特（bit）：数据的最小单位，表示为 0 或 1。 物理介质 有线 双绞线 光纤 无线 Wi-Fi 蜂窝网络 信号 电信号 网线 光信号 光纤 无线信号 Wi-Fi 蜂窝网络 ","date":"2025-11-23T16:59:31+08:00","image":"https://megumi8821.netlify.app/img/ComputerNetworks.svg","permalink":"https://megumi8821.netlify.app/p/%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/","title":"五层模型"}]